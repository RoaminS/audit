# vulnerabilities/base_vulnerability.py

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)

class BaseVulnerability(ABC):
    """
    Classe abstraite de base pour tous les types de vulnérabilités.
    Elle définit l'interface que chaque vulnérabilité doit implémenter.
    """
    
    name: str = "BaseVulnerability"
    description: str = "This is a base abstract vulnerability."
    severity: str = "Info" # Low, Medium, High, Critical
    cwe_id: str = "CWE-0" # Common Weakness Enumeration ID
    # Payloads specific to this vulnerability type (can be overridden)
    default_payloads: List[str] = []

    def __init__(self, target_url: str, method: str, params: List[Dict[str, Any]], ip_rotator: Any):
        """
        Initialise une instance de vulnérabilité.

        Args:
            target_url (str): L'URL cible à tester.
            method (str): La méthode HTTP (GET, POST, etc.).
            params (List[Dict[str, Any]]): Liste des paramètres du point d'attaque
                                           (ex: [{'name': 'id', 'value': '1'}]).
            ip_rotator (Any): Une instance de IPRotator pour gérer les requêtes.
        """
        self.target_url = target_url
        self.method = method
        self.params = params
        self.ip_rotator = ip_rotator
        self.found_vulnerabilities: List[Dict[str, Any]] = []
        logger.debug(f"Initialized {self.name} for {target_url} with method {method} and {len(params)} parameters.")

    @abstractmethod
    async def check(self) -> List[Dict[str, Any]]:
        """
        Méthode abstraite pour exécuter le test de vulnérabilité.
        Chaque sous-classe doit implémenter cette méthode.

        Returns:
            List[Dict[str, Any]]: Une liste de dictionnaires décrivant les vulnérabilités trouvées.
                                  Chaque dict devrait au minimum contenir:
                                  {'vulnerability': str, 'url': str, 'payload': str, 'proof': str, 'severity': str}
        """
        pass

    async def _make_request(self, url: str, method: str, data: Optional[Dict[str, str]] = None, headers: Optional[Dict[str, str]] = None, allow_redirects: bool = True) -> Optional[Any]:
        """
        Effectue une requête HTTP en utilisant httpx et l'IPRotator.

        Args:
            url (str): L'URL de la requête.
            method (str): La méthode HTTP (GET, POST).
            data (Optional[Dict[str, str]]): Les données pour une requête POST.
            headers (Optional[Dict[str, str]]): Les en-têtes HTTP.
            allow_redirects (bool): Suivre les redirections.

        Returns:
            Optional[Any]: L'objet réponse httpx si la requête réussit, None sinon.
        """
        try:
            async with await self.ip_rotator.get_proxies_for_request() as proxies_config:
                async with httpx.AsyncClient(proxies=proxies_config, follow_redirects=allow_redirects, timeout=10) as client:
                    if method.upper() == "GET":
                        response = await client.get(url, headers=headers)
                    elif method.upper() == "POST":
                        response = await client.post(url, data=data, headers=headers)
                    else:
                        logger.warning(f"Unsupported method {method} for request to {url}")
                        return None
                    response.raise_for_status()
                    return response
        except httpx.HTTPStatusError as e:
            logger.debug(f"HTTP error {e.response.status_code} for {url}. Rotating IP.")
            await self.ip_rotator.rotate_ip()
            return None
        except httpx.RequestError as e:
            logger.debug(f"Request error for {url}: {e}. Rotating IP.")
            await self.ip_rotator.rotate_ip()
            return None
        except Exception as e:
            logger.error(f"Unexpected error during request to {url}: {e}")
            return None

    def _report_vulnerability(self, payload: str, proof: str, description: str = None, severity: str = None):
        """
        Ajoute une vulnérabilité trouvée à la liste.

        Args:
            payload (str): Le payload utilisé pour déclencher la vulnérabilité.
            proof (str): Une preuve de la vulnérabilité (ex: texte de la réponse, URL de redirection).
            description (str, optional): Description spécifique de l'instance trouvée.
            severity (str, optional): Gravité de la vulnérabilité pour cette instance.
        """
        self.found_vulnerabilities.append({
            "vulnerability": self.name,
            "url": self.target_url,
            "method": self.method,
            "payload": payload,
            "proof": proof,
            "severity": severity if severity else self.severity,
            "description": description if description else self.description,
            "cwe_id": self.cwe_id
        })
        logger.info(f"Vulnerability '{self.name}' detected at {self.target_url} with payload '{payload}'.")

# Example for testing the abstract class (won't run directly)
if __name__ == "__main__":
    class MockIPRotator:
        async def get_proxies_for_request(self, force_tor=False):
            class AsyncProxyContext:
                async def __aenter__(self): return None
                async def __aexit__(self, exc_type, exc_val, exc_tb): pass
            return AsyncProxyContext()
        async def rotate_ip(self): pass

    # You cannot instantiate BaseVulnerability directly due to @abstractmethod
    # test_vuln = BaseVulnerability("http://example.com", "GET", [], MockIPRotator())
    # print(test_vuln.name)

    # A concrete (but incomplete) example:
    class DummyVulnerability(BaseVulnerability):
        name = "DummyTest"
        description = "A dummy vulnerability for testing base class features."
        severity = "Info"

        async def check(self) -> List[Dict[str, Any]]:
            logger.info(f"Running dummy check on {self.target_url}")
            # Simulate a check
            if "test" in self.target_url:
                self._report_vulnerability("test_payload", "Dummy proof: 'test' found in URL")
            return self.found_vulnerabilities

    async def run_dummy_test():
        ip_rotator = MockIPRotator()
        dummy_vuln = DummyVulnerability("http://example.com/test", "GET", [], ip_rotator)
        results = await dummy_vuln.check()
        print(f"\nDummy Vulnerability Test Results: {results}")

        dummy_vuln_no_match = DummyVulnerability("http://example.com/notest", "GET", [], ip_rotator)
        results_no_match = await dummy_vuln_no_match.check()
        print(f"Dummy Vulnerability Test Results (no match): {results_no_match}")

    import asyncio
    asyncio.run(run_dummy_test())
